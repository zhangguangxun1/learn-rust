简单来说：到处是 await 并不代表它变成了“同步”，更不会变慢，这正是异步编程高效的核心所在。
以下是详细解释：

1. await 并不是“阻塞”，而是“挂起”

在同步编程中，如果一个操作（如数据库查询）需要 100ms，CPU 会在这 100ms 内死等，什么都不干。
在 Actix-web 的异步方法中，当你执行 Question::find_by_id(...).await 时：
挂起（Yield）： 当前任务会释放对 CPU 线程的控制权。
非阻塞： Actix 的调度器（Runtime）会立即安排这个线程去处理其他并发请求。
恢复： 当数据库返回结果后，调度器会重新唤醒这个任务，从 await 的地方继续往下走。
结论： 线程并没有在“等”，而是在“忙别的事”。这让单线程或少量线程能同时处理成千上万个并发连接。 Actix-web 官方文档关于异步的说明。

2. 代码逻辑的“顺序性” vs 执行的“并发性”

你的代码看起来是“一步接一步”的同步逻辑（查询 -> 修改数据 -> 更新），这是因为业务逻辑本身就是有依赖的：
如果你不 await 拿到 info，你后面怎么获取 images 列表？
如果没有 images 列表，你又怎么调用 title_images？
这种逻辑上的顺序执行是必须的，即使在同步代码里也是如此。使用 await 只是用异步的方式表达了这种依赖关系，而没有牺牲系统的吞吐量。

3. 什么情况下会变慢？

只有在以下两种情况，你才需要担心性能：
没有依赖的任务却在串行 await：
如果你要查两个互不相关的数据库表，这样写会慢：
rust
let a = get_a().await; // 等 50ms
let b = get_b().await; // 再等 50ms，总共 100ms
请谨慎使用此类代码。

优化方式（并行）：
rust
let (a, b) = futures::join!(get_a(), get_b()); // 总共 50ms
请谨慎使用此类代码。

在 async 函数里执行大量计算（CPU Bound）：
如果你在 await 之间写了一个循环 10 亿次的计算，这会阻塞线程，导致异步调度器卡死。这种情况下应该使用 web::block。 Actix-web 官方关于处理阻塞代码的建议。